// Generated by purs bundle 0.13.8
var PS = {};
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Alt"] = $PS["Control.Alt"] || {};
  var exports = $PS["Control.Alt"];
  var Alt = function (Functor0, alt) {
    this.Functor0 = Functor0;
    this.alt = alt;
  };
  exports["Alt"] = Alt;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Alternative"] = $PS["Control.Alternative"] || {};
  var exports = $PS["Control.Alternative"];
  var Alternative = function (Applicative0, Plus1) {
    this.Applicative0 = Applicative0;
    this.Plus1 = Plus1;
  };
  exports["Alternative"] = Alternative;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var Semigroupoid = function (compose) {
    this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
    return function (g) {
      return function (x) {
        return f(g(x));
      };
    };
  });
  var compose = function (dict) {
    return dict.compose;
  };
  exports["compose"] = compose;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];
  var Category = function (Semigroupoid0, identity) {
    this.Semigroupoid0 = Semigroupoid0;
    this.identity = identity;
  };
  var identity = function (dict) {
    return dict.identity;
  };
  var categoryFn = new Category(
    function () {
      return Control_Semigroupoid.semigroupoidFn;
    },
    function (x) {
      return x;
    }
  );
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];
  var $$const = function (a) {
    return function (v) {
      return a;
    };
  };
  var applyFlipped = function (x) {
    return function (f) {
      return f(x);
    };
  };
  exports["const"] = $$const;
  exports["applyFlipped"] = applyFlipped;
})(PS);
(function (exports) {
  "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})((PS["Data.Functor"] = PS["Data.Functor"] || {}));
(function (exports) {
  "use strict";

  exports.unit = {};
})((PS["Data.Unit"] = PS["Data.Unit"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];
  var $foreign = $PS["Data.Functor"];
  var Data_Function = $PS["Data.Function"];
  var Data_Unit = $PS["Data.Unit"];
  var Functor = function (map) {
    this.map = map;
  };
  var map = function (dict) {
    return dict.map;
  };
  var $$void = function (dictFunctor) {
    return map(dictFunctor)(Data_Function["const"](Data_Unit.unit));
  };
  var functorArray = new Functor($foreign.arrayMap);
  exports["Functor"] = Functor;
  exports["map"] = map;
  exports["void"] = $$void;
  exports["functorArray"] = functorArray;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Apply = function (Functor0, apply) {
    this.Functor0 = Functor0;
    this.apply = apply;
  };
  var apply = function (dict) {
    return dict.apply;
  };
  var applySecond = function (dictApply) {
    return function (a) {
      return function (b) {
        return apply(dictApply)(
          Data_Functor.map(dictApply.Functor0())(
            Data_Function["const"](
              Control_Category.identity(Control_Category.categoryFn)
            )
          )(a)
        )(b);
      };
    };
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
  exports["applySecond"] = applySecond;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Applicative = function (Apply0, pure) {
    this.Apply0 = Apply0;
    this.pure = pure;
  };
  var pure = function (dict) {
    return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
    return function (f) {
      return function (a) {
        return Control_Apply.apply(dictApplicative.Apply0())(
          pure(dictApplicative)(f)
        )(a);
      };
    };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var Bind = function (Apply0, bind) {
    this.Apply0 = Apply0;
    this.bind = bind;
  };
  var bind = function (dict) {
    return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Monad = function (Applicative0, Bind1) {
    this.Applicative0 = Applicative0;
    this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
    return function (f) {
      return function (a) {
        return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {
          return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {
            return Control_Applicative.pure(dictMonad.Applicative0())(
              f$prime(a$prime)
            );
          });
        });
      };
    };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Control.Plus"] = $PS["Control.Plus"] || {};
  var exports = $PS["Control.Plus"];
  var Plus = function (Alt0, empty) {
    this.Alt0 = Alt0;
    this.empty = empty;
  };
  exports["Plus"] = Plus;
})(PS);
(function (exports) {
  "use strict";

  //------------------------------------------------------------------------------
  // Array creation --------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.range = function (start) {
    return function (end) {
      var step = start > end ? -1 : 1;
      var result = new Array(step * (end - start) + 1);
      var i = start,
        n = 0;
      while (i !== end) {
        result[n++] = i;
        i += step;
      }
      result[n] = i;
      return result;
    };
  };

  var replicateFill = function (count) {
    return function (value) {
      if (count < 1) {
        return [];
      }
      var result = new Array(count);
      return result.fill(value);
    };
  };

  var replicatePolyfill = function (count) {
    return function (value) {
      var result = [];
      var n = 0;
      for (var i = 0; i < count; i++) {
        result[n++] = value;
      }
      return result;
    };
  };

  // In browsers that have Array.prototype.fill we use it, as it's faster.
  exports.replicate =
    typeof Array.prototype.fill === "function"
      ? replicateFill
      : replicatePolyfill;

  //------------------------------------------------------------------------------
  // Array size ------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.length = function (xs) {
    return xs.length;
  };

  //------------------------------------------------------------------------------
  // Indexed operations ----------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.indexImpl = function (just) {
    return function (nothing) {
      return function (xs) {
        return function (i) {
          return i < 0 || i >= xs.length ? nothing : just(xs[i]);
        };
      };
    };
  };

  exports.findIndexImpl = function (just) {
    return function (nothing) {
      return function (f) {
        return function (xs) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (f(xs[i])) return just(i);
          }
          return nothing;
        };
      };
    };
  };

  exports._deleteAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (l) {
          if (i < 0 || i >= l.length) return nothing;
          var l1 = l.slice();
          l1.splice(i, 1);
          return just(l1);
        };
      };
    };
  };

  //------------------------------------------------------------------------------
  // Zipping ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.zipWith = function (f) {
    return function (xs) {
      return function (ys) {
        var l = xs.length < ys.length ? xs.length : ys.length;
        var result = new Array(l);
        for (var i = 0; i < l; i++) {
          result[i] = f(xs[i])(ys[i]);
        }
        return result;
      };
    };
  };
})((PS["Data.Array"] = PS["Data.Array"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Nothing = (function () {
    function Nothing() {}
    Nothing.value = new Nothing();
    return Nothing;
  })();
  var Just = (function () {
    function Just(value0) {
      this.value0 = value0;
    }
    Just.create = function (value0) {
      return new Just(value0);
    };
    return Just;
  })();
  var maybe = function (v) {
    return function (v1) {
      return function (v2) {
        if (v2 instanceof Nothing) {
          return v;
        }
        if (v2 instanceof Just) {
          return v1(v2.value0);
        }
        throw new Error(
          "Failed pattern match at Data.Maybe (line 217, column 1 - line 217, column 51): " +
            [v.constructor.name, v1.constructor.name, v2.constructor.name]
        );
      };
    };
  };
  var isJust = maybe(false)(Data_Function["const"](true));
  var functorMaybe = new Data_Functor.Functor(function (v) {
    return function (v1) {
      if (v1 instanceof Just) {
        return new Just(v(v1.value0));
      }
      return Nothing.value;
    };
  });
  var fromMaybe = function (a) {
    return maybe(a)(Control_Category.identity(Control_Category.categoryFn));
  };
  var fromJust = function (dictPartial) {
    return function (v) {
      if (v instanceof Just) {
        return v.value0;
      }
      throw new Error(
        "Failed pattern match at Data.Maybe (line 268, column 1 - line 268, column 46): " +
          [v.constructor.name]
      );
    };
  };
  var applyMaybe = new Control_Apply.Apply(
    function () {
      return functorMaybe;
    },
    function (v) {
      return function (v1) {
        if (v instanceof Just) {
          return Data_Functor.map(functorMaybe)(v.value0)(v1);
        }
        if (v instanceof Nothing) {
          return Nothing.value;
        }
        throw new Error(
          "Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " +
            [v.constructor.name, v1.constructor.name]
        );
      };
    }
  );
  var bindMaybe = new Control_Bind.Bind(
    function () {
      return applyMaybe;
    },
    function (v) {
      return function (v1) {
        if (v instanceof Just) {
          return v1(v.value0);
        }
        if (v instanceof Nothing) {
          return Nothing.value;
        }
        throw new Error(
          "Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " +
            [v.constructor.name, v1.constructor.name]
        );
      };
    }
  );
  var applicativeMaybe = new Control_Applicative.Applicative(function () {
    return applyMaybe;
  }, Just.create);
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["maybe"] = maybe;
  exports["fromMaybe"] = fromMaybe;
  exports["isJust"] = isJust;
  exports["fromJust"] = fromJust;
  exports["functorMaybe"] = functorMaybe;
  exports["applicativeMaybe"] = applicativeMaybe;
  exports["bindMaybe"] = bindMaybe;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Array"] = $PS["Data.Array"] || {};
  var exports = $PS["Data.Array"];
  var $foreign = $PS["Data.Array"];
  var Data_Maybe = $PS["Data.Maybe"];
  var mapWithIndex = function (f) {
    return function (xs) {
      return $foreign.zipWith(f)(
        $foreign.range(0)(($foreign.length(xs) - 1) | 0)
      )(xs);
    };
  };
  var index = $foreign.indexImpl(Data_Maybe.Just.create)(
    Data_Maybe.Nothing.value
  );
  var head = function (xs) {
    return index(xs)(0);
  };
  var findIndex = $foreign.findIndexImpl(Data_Maybe.Just.create)(
    Data_Maybe.Nothing.value
  );
  var deleteAt = $foreign["_deleteAt"](Data_Maybe.Just.create)(
    Data_Maybe.Nothing.value
  );
  var deleteBy = function (v) {
    return function (v1) {
      return function (v2) {
        if (v2.length === 0) {
          return [];
        }
        return Data_Maybe.maybe(v2)(function (i) {
          return Data_Maybe.fromJust()(deleteAt(i)(v2));
        })(findIndex(v(v1))(v2));
      };
    };
  };
  exports["head"] = head;
  exports["index"] = index;
  exports["mapWithIndex"] = mapWithIndex;
  exports["deleteBy"] = deleteBy;
  exports["range"] = $foreign.range;
  exports["replicate"] = $foreign.replicate;
  exports["length"] = $foreign.length;
  exports["zipWith"] = $foreign.zipWith;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Boolean"] = $PS["Data.Boolean"] || {};
  var exports = $PS["Data.Boolean"];
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS);
(function (exports) {
  "use strict";

  exports.topInt = 2147483647;
  exports.bottomInt = -2147483648;
})((PS["Data.Bounded"] = PS["Data.Bounded"] || {}));
(function (exports) {
  "use strict";

  var unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x === y ? eq : gt;
          };
        };
      };
    };
  };
  exports.ordIntImpl = unsafeCompareImpl;
})((PS["Data.Ord"] = PS["Data.Ord"] || {}));
(function (exports) {
  "use strict";

  var refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };
  exports.eqIntImpl = refEq;
})((PS["Data.Eq"] = PS["Data.Eq"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Eq"] = $PS["Data.Eq"] || {};
  var exports = $PS["Data.Eq"];
  var $foreign = $PS["Data.Eq"];
  var Eq = function (eq) {
    this.eq = eq;
  };
  var eqInt = new Eq($foreign.eqIntImpl);
  exports["eqInt"] = eqInt;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Ordering"] = $PS["Data.Ordering"] || {};
  var exports = $PS["Data.Ordering"];
  var LT = (function () {
    function LT() {}
    LT.value = new LT();
    return LT;
  })();
  var GT = (function () {
    function GT() {}
    GT.value = new GT();
    return GT;
  })();
  var EQ = (function () {
    function EQ() {}
    EQ.value = new EQ();
    return EQ;
  })();
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Ord"] = $PS["Data.Ord"] || {};
  var exports = $PS["Data.Ord"];
  var $foreign = $PS["Data.Ord"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Ord = function (Eq0, compare) {
    this.Eq0 = Eq0;
    this.compare = compare;
  };
  var ordInt = new Ord(function () {
    return Data_Eq.eqInt;
  }, $foreign.ordIntImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(
    Data_Ordering.GT.value
  ));
  exports["ordInt"] = ordInt;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Bounded"] = $PS["Data.Bounded"] || {};
  var exports = $PS["Data.Bounded"];
  var $foreign = $PS["Data.Bounded"];
  var Data_Ord = $PS["Data.Ord"];
  var Bounded = function (Ord0, bottom, top) {
    this.Ord0 = Ord0;
    this.bottom = bottom;
    this.top = top;
  };
  var top = function (dict) {
    return dict.top;
  };
  var boundedInt = new Bounded(
    function () {
      return Data_Ord.ordInt;
    },
    $foreign.bottomInt,
    $foreign.topInt
  );
  var bottom = function (dict) {
    return dict.bottom;
  };
  exports["bottom"] = bottom;
  exports["top"] = top;
  exports["boundedInt"] = boundedInt;
})(PS);
(function (exports) {
  "use strict";

  exports.intSub = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return (x - y) | 0;
    };
  };
})((PS["Data.Ring"] = PS["Data.Ring"] || {}));
(function (exports) {
  "use strict";

  exports.intAdd = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return (x + y) | 0;
    };
  };

  exports.intMul = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return (x * y) | 0;
    };
  };

  exports.numAdd = function (n1) {
    return function (n2) {
      return n1 + n2;
    };
  };

  exports.numMul = function (n1) {
    return function (n2) {
      return n1 * n2;
    };
  };
})((PS["Data.Semiring"] = PS["Data.Semiring"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Semiring"] = $PS["Data.Semiring"] || {};
  var exports = $PS["Data.Semiring"];
  var $foreign = $PS["Data.Semiring"];
  var Semiring = function (add, mul, one, zero) {
    this.add = add;
    this.mul = mul;
    this.one = one;
    this.zero = zero;
  };
  var semiringNumber = new Semiring($foreign.numAdd, $foreign.numMul, 1.0, 0.0);
  var semiringInt = new Semiring($foreign.intAdd, $foreign.intMul, 1, 0);
  var add = function (dict) {
    return dict.add;
  };
  exports["add"] = add;
  exports["semiringInt"] = semiringInt;
  exports["semiringNumber"] = semiringNumber;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Ring"] = $PS["Data.Ring"] || {};
  var exports = $PS["Data.Ring"];
  var $foreign = $PS["Data.Ring"];
  var Data_Semiring = $PS["Data.Semiring"];
  var Ring = function (Semiring0, sub) {
    this.Semiring0 = Semiring0;
    this.sub = sub;
  };
  var ringInt = new Ring(function () {
    return Data_Semiring.semiringInt;
  }, $foreign.intSub);
  exports["ringInt"] = ringInt;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.CommutativeRing"] = $PS["Data.CommutativeRing"] || {};
  var exports = $PS["Data.CommutativeRing"];
  var Data_Ring = $PS["Data.Ring"];
  var CommutativeRing = function (Ring0) {
    this.Ring0 = Ring0;
  };
  var commutativeRingInt = new CommutativeRing(function () {
    return Data_Ring.ringInt;
  });
  exports["commutativeRingInt"] = commutativeRingInt;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Compactable"] = $PS["Data.Compactable"] || {};
  var exports = $PS["Data.Compactable"];
  var Compactable = function (compact, separate) {
    this.compact = compact;
    this.separate = separate;
  };
  exports["Compactable"] = Compactable;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Either"] = $PS["Data.Either"] || {};
  var exports = $PS["Data.Either"];
  var Data_Function = $PS["Data.Function"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Left = (function () {
    function Left(value0) {
      this.value0 = value0;
    }
    Left.create = function (value0) {
      return new Left(value0);
    };
    return Left;
  })();
  var Right = (function () {
    function Right(value0) {
      this.value0 = value0;
    }
    Right.create = function (value0) {
      return new Right(value0);
    };
    return Right;
  })();
  var fromRight = function (dictPartial) {
    return function (v) {
      if (v instanceof Right) {
        return v.value0;
      }
      throw new Error(
        "Failed pattern match at Data.Either (line 261, column 1 - line 261, column 52): " +
          [v.constructor.name]
      );
    };
  };
  var fromLeft = function (dictPartial) {
    return function (v) {
      if (v instanceof Left) {
        return v.value0;
      }
      throw new Error(
        "Failed pattern match at Data.Either (line 256, column 1 - line 256, column 51): " +
          [v.constructor.name]
      );
    };
  };
  var either = function (v) {
    return function (v1) {
      return function (v2) {
        if (v2 instanceof Left) {
          return v(v2.value0);
        }
        if (v2 instanceof Right) {
          return v1(v2.value0);
        }
        throw new Error(
          "Failed pattern match at Data.Either (line 238, column 1 - line 238, column 64): " +
            [v.constructor.name, v1.constructor.name, v2.constructor.name]
        );
      };
    };
  };
  var hush = either(Data_Function["const"](Data_Maybe.Nothing.value))(
    Data_Maybe.Just.create
  );
  var isLeft = either(Data_Function["const"](true))(
    Data_Function["const"](false)
  );
  var isRight = either(Data_Function["const"](false))(
    Data_Function["const"](true)
  );
  exports["either"] = either;
  exports["isLeft"] = isLeft;
  exports["isRight"] = isRight;
  exports["fromLeft"] = fromLeft;
  exports["fromRight"] = fromRight;
  exports["hush"] = hush;
})(PS);
(function (exports) {
  "use strict";

  exports.intDegree = function (x) {
    return Math.min(Math.abs(x), 2147483647);
  };

  // See the Euclidean definition in
  // https://en.m.wikipedia.org/wiki/Modulo_operation.
  exports.intDiv = function (x) {
    return function (y) {
      if (y === 0) return 0;
      return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
    };
  };

  exports.intMod = function (x) {
    return function (y) {
      if (y === 0) return 0;
      var yy = Math.abs(y);
      return ((x % yy) + yy) % yy;
    };
  };
})((PS["Data.EuclideanRing"] = PS["Data.EuclideanRing"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.EuclideanRing"] = $PS["Data.EuclideanRing"] || {};
  var exports = $PS["Data.EuclideanRing"];
  var $foreign = $PS["Data.EuclideanRing"];
  var Data_CommutativeRing = $PS["Data.CommutativeRing"];
  var EuclideanRing = function (CommutativeRing0, degree, div, mod) {
    this.CommutativeRing0 = CommutativeRing0;
    this.degree = degree;
    this.div = div;
    this.mod = mod;
  };
  var euclideanRingInt = new EuclideanRing(
    function () {
      return Data_CommutativeRing.commutativeRingInt;
    },
    $foreign.intDegree,
    $foreign.intDiv,
    $foreign.intMod
  );
  var div = function (dict) {
    return dict.div;
  };
  exports["div"] = div;
  exports["euclideanRingInt"] = euclideanRingInt;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Filterable"] = $PS["Data.Filterable"] || {};
  var exports = $PS["Data.Filterable"];
  var Filterable = function (
    Compactable0,
    Functor1,
    filter,
    filterMap,
    partition,
    partitionMap
  ) {
    this.Compactable0 = Compactable0;
    this.Functor1 = Functor1;
    this.filter = filter;
    this.filterMap = filterMap;
    this.partition = partition;
    this.partitionMap = partitionMap;
  };
  var filterMap = function (dict) {
    return dict.filterMap;
  };
  exports["Filterable"] = Filterable;
  exports["filterMap"] = filterMap;
})(PS);
(function (exports) {
  "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})((PS["Data.Foldable"] = PS["Data.Foldable"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Monoid"] = $PS["Data.Monoid"] || {};
  var exports = $PS["Data.Monoid"];
  var mempty = function (dict) {
    return dict.mempty;
  };
  exports["mempty"] = mempty;
})(PS);
(function (exports) {
  "use strict";

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})((PS["Data.Semigroup"] = PS["Data.Semigroup"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Semigroup"] = $PS["Data.Semigroup"] || {};
  var exports = $PS["Data.Semigroup"];
  var $foreign = $PS["Data.Semigroup"];
  var Semigroup = function (append) {
    this.append = append;
  };
  var semigroupArray = new Semigroup($foreign.concatArray);
  var append = function (dict) {
    return dict.append;
  };
  exports["append"] = append;
  exports["semigroupArray"] = semigroupArray;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Foldable"] = $PS["Data.Foldable"] || {};
  var exports = $PS["Data.Foldable"];
  var $foreign = $PS["Data.Foldable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Unit = $PS["Data.Unit"];
  var Foldable = function (foldMap, foldl, foldr) {
    this.foldMap = foldMap;
    this.foldl = foldl;
    this.foldr = foldr;
  };
  var foldr = function (dict) {
    return dict.foldr;
  };
  var traverse_ = function (dictApplicative) {
    return function (dictFoldable) {
      return function (f) {
        return foldr(dictFoldable)(
          (function () {
            var $197 = Control_Apply.applySecond(dictApplicative.Apply0());
            return function ($198) {
              return $197(f($198));
            };
          })()
        )(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
      };
    };
  };
  var sequence_ = function (dictApplicative) {
    return function (dictFoldable) {
      return traverse_(dictApplicative)(dictFoldable)(
        Control_Category.identity(Control_Category.categoryFn)
      );
    };
  };
  var foldableMaybe = new Foldable(
    function (dictMonoid) {
      return function (f) {
        return function (v) {
          if (v instanceof Data_Maybe.Nothing) {
            return Data_Monoid.mempty(dictMonoid);
          }
          if (v instanceof Data_Maybe.Just) {
            return f(v.value0);
          }
          throw new Error(
            "Failed pattern match at Data.Foldable (line 129, column 1 - line 135, column 27): " +
              [f.constructor.name, v.constructor.name]
          );
        };
      };
    },
    function (v) {
      return function (z) {
        return function (v1) {
          if (v1 instanceof Data_Maybe.Nothing) {
            return z;
          }
          if (v1 instanceof Data_Maybe.Just) {
            return v(z)(v1.value0);
          }
          throw new Error(
            "Failed pattern match at Data.Foldable (line 129, column 1 - line 135, column 27): " +
              [v.constructor.name, z.constructor.name, v1.constructor.name]
          );
        };
      };
    },
    function (v) {
      return function (z) {
        return function (v1) {
          if (v1 instanceof Data_Maybe.Nothing) {
            return z;
          }
          if (v1 instanceof Data_Maybe.Just) {
            return v(v1.value0)(z);
          }
          throw new Error(
            "Failed pattern match at Data.Foldable (line 129, column 1 - line 135, column 27): " +
              [v.constructor.name, z.constructor.name, v1.constructor.name]
          );
        };
      };
    }
  );
  var foldMapDefaultR = function (dictFoldable) {
    return function (dictMonoid) {
      return function (f) {
        return foldr(dictFoldable)(function (x) {
          return function (acc) {
            return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
          };
        })(Data_Monoid.mempty(dictMonoid));
      };
    };
  };
  var foldableArray = new Foldable(
    function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
    },
    $foreign.foldlArray,
    $foreign.foldrArray
  );
  exports["traverse_"] = traverse_;
  exports["sequence_"] = sequence_;
  exports["foldableArray"] = foldableArray;
  exports["foldableMaybe"] = foldableMaybe;
})(PS);
(function (exports) {
  "use strict";

  exports.boolConj = function (b1) {
    return function (b2) {
      return b1 && b2;
    };
  };

  exports.boolDisj = function (b1) {
    return function (b2) {
      return b1 || b2;
    };
  };

  exports.boolNot = function (b) {
    return !b;
  };
})((PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.HeytingAlgebra"] = $PS["Data.HeytingAlgebra"] || {};
  var exports = $PS["Data.HeytingAlgebra"];
  var $foreign = $PS["Data.HeytingAlgebra"];
  var HeytingAlgebra = function (conj, disj, ff, implies, not, tt) {
    this.conj = conj;
    this.disj = disj;
    this.ff = ff;
    this.implies = implies;
    this.not = not;
    this.tt = tt;
  };
  var not = function (dict) {
    return dict.not;
  };
  var disj = function (dict) {
    return dict.disj;
  };
  var heytingAlgebraBoolean = new HeytingAlgebra(
    $foreign.boolConj,
    $foreign.boolDisj,
    false,
    function (a) {
      return function (b) {
        return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
      };
    },
    $foreign.boolNot,
    true
  );
  exports["not"] = not;
  exports["heytingAlgebraBoolean"] = heytingAlgebraBoolean;
})(PS);
(function (exports) {
  "use strict";

  exports.fromNumberImpl = function (just) {
    return function (nothing) {
      return function (n) {
        /* jshint bitwise: false */
        return (n | 0) === n ? just(n) : nothing;
      };
    };
  };

  exports.toNumber = function (n) {
    return n;
  };
})((PS["Data.Int"] = PS["Data.Int"] || {}));
(function (exports) {
  /* globals exports */
  "use strict";

  exports.infinity = Infinity;
})((PS["Global"] = PS["Global"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Global"] = $PS["Global"] || {};
  var exports = $PS["Global"];
  var $foreign = $PS["Global"];
  exports["infinity"] = $foreign.infinity;
})(PS);
(function (exports) {
  "use strict";

  exports.floor = Math.floor;
})((PS["Math"] = PS["Math"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Math"] = $PS["Math"] || {};
  var exports = $PS["Math"];
  var $foreign = $PS["Math"];
  exports["floor"] = $foreign.floor;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Int"] = $PS["Data.Int"] || {};
  var exports = $PS["Data.Int"];
  var $foreign = $PS["Data.Int"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Bounded = $PS["Data.Bounded"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Global = $PS["Global"];
  var $$Math = $PS["Math"];
  var fromNumber = $foreign.fromNumberImpl(Data_Maybe.Just.create)(
    Data_Maybe.Nothing.value
  );
  var unsafeClamp = function (x) {
    if (x === Global.infinity) {
      return 0;
    }
    if (x === -Global.infinity) {
      return 0;
    }
    if (x >= $foreign.toNumber(Data_Bounded.top(Data_Bounded.boundedInt))) {
      return Data_Bounded.top(Data_Bounded.boundedInt);
    }
    if (x <= $foreign.toNumber(Data_Bounded.bottom(Data_Bounded.boundedInt))) {
      return Data_Bounded.bottom(Data_Bounded.boundedInt);
    }
    if (Data_Boolean.otherwise) {
      return Data_Maybe.fromMaybe(0)(fromNumber(x));
    }
    throw new Error(
      "Failed pattern match at Data.Int (line 66, column 1 - line 66, column 29): " +
        [x.constructor.name]
    );
  };
  var floor = function ($24) {
    return unsafeClamp($$Math.floor($24));
  };
  exports["floor"] = floor;
  exports["toNumber"] = $foreign.toNumber;
})(PS);
(function (exports) {
  "use strict";

  exports.showNumberImpl = function (n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };

  exports.showArrayImpl = function (f) {
    return function (xs) {
      var ss = [];
      for (var i = 0, l = xs.length; i < l; i++) {
        ss[i] = f(xs[i]);
      }
      return "[" + ss.join(",") + "]";
    };
  };
})((PS["Data.Show"] = PS["Data.Show"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var Show = function (show) {
    this.show = show;
  };
  var showNumber = new Show($foreign.showNumberImpl);
  var show = function (dict) {
    return dict.show;
  };
  var showArray = function (dictShow) {
    return new Show($foreign.showArrayImpl(show(dictShow)));
  };
  exports["show"] = show;
  exports["showNumber"] = showNumber;
  exports["showArray"] = showArray;
})(PS);
(function (exports) {
  "use strict";

  // jshint maxparams: 3

  exports.traverseArrayImpl = (function () {
    function array1(a) {
      return [a];
    }

    function array2(a) {
      return function (b) {
        return [a, b];
      };
    }

    function array3(a) {
      return function (b) {
        return function (c) {
          return [a, b, c];
        };
      };
    }

    function concat2(xs) {
      return function (ys) {
        return xs.concat(ys);
      };
    }

    return function (apply) {
      return function (map) {
        return function (pure) {
          return function (f) {
            return function (array) {
              function go(bot, top) {
                switch (top - bot) {
                  case 0:
                    return pure([]);
                  case 1:
                    return map(array1)(f(array[bot]));
                  case 2:
                    return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));
                  case 3:
                    return apply(
                      apply(map(array3)(f(array[bot])))(f(array[bot + 1]))
                    )(f(array[bot + 2]));
                  default:
                    // This slightly tricky pivot selection aims to produce two
                    // even-length partitions where possible.
                    var pivot = bot + Math.floor((top - bot) / 4) * 2;
                    return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));
                }
              }
              return go(0, array.length);
            };
          };
        };
      };
    };
  })();
})((PS["Data.Traversable"] = PS["Data.Traversable"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Data.Traversable"] = $PS["Data.Traversable"] || {};
  var exports = $PS["Data.Traversable"];
  var $foreign = $PS["Data.Traversable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Traversable = function (Foldable1, Functor0, sequence, traverse) {
    this.Foldable1 = Foldable1;
    this.Functor0 = Functor0;
    this.sequence = sequence;
    this.traverse = traverse;
  };
  var traverse = function (dict) {
    return dict.traverse;
  };
  var traversableMaybe = new Traversable(
    function () {
      return Data_Foldable.foldableMaybe;
    },
    function () {
      return Data_Maybe.functorMaybe;
    },
    function (dictApplicative) {
      return function (v) {
        if (v instanceof Data_Maybe.Nothing) {
          return Control_Applicative.pure(dictApplicative)(
            Data_Maybe.Nothing.value
          );
        }
        if (v instanceof Data_Maybe.Just) {
          return Data_Functor.map(dictApplicative.Apply0().Functor0())(
            Data_Maybe.Just.create
          )(v.value0);
        }
        throw new Error(
          "Failed pattern match at Data.Traversable (line 86, column 1 - line 90, column 33): " +
            [v.constructor.name]
        );
      };
    },
    function (dictApplicative) {
      return function (v) {
        return function (v1) {
          if (v1 instanceof Data_Maybe.Nothing) {
            return Control_Applicative.pure(dictApplicative)(
              Data_Maybe.Nothing.value
            );
          }
          if (v1 instanceof Data_Maybe.Just) {
            return Data_Functor.map(dictApplicative.Apply0().Functor0())(
              Data_Maybe.Just.create
            )(v(v1.value0));
          }
          throw new Error(
            "Failed pattern match at Data.Traversable (line 86, column 1 - line 90, column 33): " +
              [v.constructor.name, v1.constructor.name]
          );
        };
      };
    }
  );
  var sequenceDefault = function (dictTraversable) {
    return function (dictApplicative) {
      return traverse(dictTraversable)(dictApplicative)(
        Control_Category.identity(Control_Category.categoryFn)
      );
    };
  };
  var traversableArray = new Traversable(
    function () {
      return Data_Foldable.foldableArray;
    },
    function () {
      return Data_Functor.functorArray;
    },
    function (dictApplicative) {
      return sequenceDefault(traversableArray)(dictApplicative);
    },
    function (dictApplicative) {
      return $foreign.traverseArrayImpl(
        Control_Apply.apply(dictApplicative.Apply0())
      )(Data_Functor.map(dictApplicative.Apply0().Functor0()))(
        Control_Applicative.pure(dictApplicative)
      );
    }
  );
  var sequence = function (dict) {
    return dict.sequence;
  };
  exports["sequence"] = sequence;
  exports["traversableArray"] = traversableArray;
  exports["traversableMaybe"] = traversableMaybe;
})(PS);
(function (exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };

  exports.whileE = function (f) {
    return function (a) {
      return function () {
        while (f()) {
          a();
        }
        return {};
      };
    };
  };
})((PS["Effect"] = PS["Effect"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];
  var monadEffect = new Control_Monad.Monad(
    function () {
      return applicativeEffect;
    },
    function () {
      return bindEffect;
    }
  );
  var bindEffect = new Control_Bind.Bind(function () {
    return applyEffect;
  }, $foreign.bindE);
  var applyEffect = new Control_Apply.Apply(function () {
    return functorEffect;
  }, Control_Monad.ap(monadEffect));
  var applicativeEffect = new Control_Applicative.Applicative(function () {
    return applyEffect;
  }, $foreign.pureE);
  var functorEffect = new Data_Functor.Functor(
    Control_Applicative.liftA1(applicativeEffect)
  );
  exports["functorEffect"] = functorEffect;
  exports["applyEffect"] = applyEffect;
  exports["applicativeEffect"] = applicativeEffect;
  exports["bindEffect"] = bindEffect;
  exports["monadEffect"] = monadEffect;
  exports["whileE"] = $foreign.whileE;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect.Class"] = $PS["Effect.Class"] || {};
  var exports = $PS["Effect.Class"];
  var Control_Category = $PS["Control.Category"];
  var Effect = $PS["Effect"];
  var MonadEffect = function (Monad0, liftEffect) {
    this.Monad0 = Monad0;
    this.liftEffect = liftEffect;
  };
  var monadEffectEffect = new MonadEffect(function () {
    return Effect.monadEffect;
  }, Control_Category.identity(Control_Category.categoryFn));
  var liftEffect = function (dict) {
    return dict.liftEffect;
  };
  exports["liftEffect"] = liftEffect;
  exports["monadEffectEffect"] = monadEffectEffect;
})(PS);
(function (exports) {
  "use strict";

  exports.log = function (s) {
    return function () {
      console.log(s);
      return {};
    };
  };
})((PS["Effect.Console"] = PS["Effect.Console"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect.Console"] = $PS["Effect.Console"] || {};
  var exports = $PS["Effect.Console"];
  var $foreign = $PS["Effect.Console"];
  exports["log"] = $foreign.log;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect.Class.Console"] = $PS["Effect.Class.Console"] || {};
  var exports = $PS["Effect.Class.Console"];
  var Effect_Class = $PS["Effect.Class"];
  var Effect_Console = $PS["Effect.Console"];
  var log = function (dictMonadEffect) {
    var $30 = Effect_Class.liftEffect(dictMonadEffect);
    return function ($31) {
      return $30(Effect_Console.log($31));
    };
  };
  exports["log"] = log;
})(PS);
(function (exports) {
  "use strict";

  exports.new = function (val) {
    return function () {
      return { value: val };
    };
  };

  exports.read = function (ref) {
    return function () {
      return ref.value;
    };
  };

  exports["modify'"] = function (f) {
    return function (ref) {
      return function () {
        var t = f(ref.value);
        ref.value = t.state;
        return t.value;
      };
    };
  };

  exports.write = function (val) {
    return function (ref) {
      return function () {
        ref.value = val;
        return {};
      };
    };
  };
})((PS["Effect.Ref"] = PS["Effect.Ref"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect.Ref"] = $PS["Effect.Ref"] || {};
  var exports = $PS["Effect.Ref"];
  var $foreign = $PS["Effect.Ref"];
  var modify = function (f) {
    return $foreign["modify'"](function (s) {
      var s$prime = f(s);
      return {
        state: s$prime,
        value: s$prime,
      };
    });
  };
  exports["modify"] = modify;
  exports["new"] = $foreign["new"];
  exports["read"] = $foreign.read;
  exports["write"] = $foreign.write;
})(PS);
(function (exports) {
  "use strict";

  exports.unsafePerformEffect = function (f) {
    return f();
  };
})((PS["Effect.Unsafe"] = PS["Effect.Unsafe"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Effect.Unsafe"] = $PS["Effect.Unsafe"] || {};
  var exports = $PS["Effect.Unsafe"];
  var $foreign = $PS["Effect.Unsafe"];
  exports["unsafePerformEffect"] = $foreign.unsafePerformEffect;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["FRP.Behavior"] = $PS["FRP.Behavior"] || {};
  var exports = $PS["FRP.Behavior"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var ABehavior = function (x) {
    return x;
  };
  var sample = function (v) {
    return function (e) {
      return v(e);
    };
  };
  var functorABehavior = function (dictFunctor) {
    return new Data_Functor.Functor(function (f) {
      return function (v) {
        return function (e) {
          return v(
            Data_Functor.map(dictFunctor)(function (v1) {
              return function ($66) {
                return v1(f($66));
              };
            })(e)
          );
        };
      };
    });
  };
  var sampleBy = function (dictIsEvent) {
    return function (f) {
      return function (b) {
        return function (e) {
          return sample(
            Data_Functor.map(
              functorABehavior(dictIsEvent.Filterable1().Functor1())
            )(f)(b)
          )(
            Data_Functor.map(dictIsEvent.Filterable1().Functor1())(
              Data_Function.applyFlipped
            )(e)
          );
        };
      };
    };
  };
  var sample_ = function (dictIsEvent) {
    return sampleBy(dictIsEvent)(Data_Function["const"]);
  };
  var behavior = ABehavior;
  var applyABehavior = function (dictFunctor) {
    return new Control_Apply.Apply(
      function () {
        return functorABehavior(dictFunctor);
      },
      function (v) {
        return function (v1) {
          return function (e) {
            return v1(
              v(
                Data_Functor.map(dictFunctor)(
                  Control_Semigroupoid.compose(
                    Control_Semigroupoid.semigroupoidFn
                  )
                )(e)
              )
            );
          };
        };
      }
    );
  };
  exports["behavior"] = behavior;
  exports["sample_"] = sample_;
  exports["functorABehavior"] = functorABehavior;
  exports["applyABehavior"] = applyABehavior;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["FRP.Event.Class"] = $PS["FRP.Event.Class"] || {};
  var exports = $PS["FRP.Event.Class"];
  var IsEvent = function (
    Alternative0,
    Filterable1,
    fix,
    fold,
    keepLatest,
    sampleOn
  ) {
    this.Alternative0 = Alternative0;
    this.Filterable1 = Filterable1;
    this.fix = fix;
    this.fold = fold;
    this.keepLatest = keepLatest;
    this.sampleOn = sampleOn;
  };
  exports["IsEvent"] = IsEvent;
})(PS);
(function (exports) {
  "use strict";

  exports.reallyUnsafeRefEq = function (a) {
    return function (b) {
      return a === b;
    };
  };
})((PS["Unsafe.Reference"] = PS["Unsafe.Reference"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Unsafe.Reference"] = $PS["Unsafe.Reference"] || {};
  var exports = $PS["Unsafe.Reference"];
  var $foreign = $PS["Unsafe.Reference"];
  var unsafeRefEq = $foreign.reallyUnsafeRefEq;
  exports["unsafeRefEq"] = unsafeRefEq;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["FRP.Event"] = $PS["FRP.Event"] || {};
  var exports = $PS["FRP.Event"];
  var Control_Alt = $PS["Control.Alt"];
  var Control_Alternative = $PS["Control.Alternative"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Plus = $PS["Control.Plus"];
  var Data_Array = $PS["Data.Array"];
  var Data_Compactable = $PS["Data.Compactable"];
  var Data_Either = $PS["Data.Either"];
  var Data_Filterable = $PS["Data.Filterable"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_HeytingAlgebra = $PS["Data.HeytingAlgebra"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Unit = $PS["Data.Unit"];
  var Effect = $PS["Effect"];
  var Effect_Ref = $PS["Effect.Ref"];
  var Effect_Unsafe = $PS["Effect.Unsafe"];
  var FRP_Event_Class = $PS["FRP.Event.Class"];
  var Unsafe_Reference = $PS["Unsafe.Reference"];
  var Event = function (x) {
    return x;
  };
  var subscribe = function (v) {
    return function (k) {
      return v(
        (function () {
          var $45 = Data_Functor["void"](Effect.functorEffect);
          return function ($46) {
            return $45(k($46));
          };
        })()
      );
    };
  };
  var sampleOn = function (v) {
    return function (v1) {
      return function (k) {
        return function __do() {
          var latest = Effect_Ref["new"](Data_Maybe.Nothing.value)();
          var c1 = v(function (a) {
            return Effect_Ref.write(new Data_Maybe.Just(a))(latest);
          })();
          var c2 = v1(function (f) {
            return Control_Bind.bind(Effect.bindEffect)(
              Effect_Ref.read(latest)
            )(
              Data_Foldable.traverse_(Effect.applicativeEffect)(
                Data_Foldable.foldableMaybe
              )(function ($47) {
                return k(f($47));
              })
            );
          })();
          return Control_Apply.applySecond(Effect.applyEffect)(c1)(c2);
        };
      };
    };
  };
  var makeEvent = Event;
  var keepLatest = function (v) {
    return function (k) {
      return function __do() {
        var cancelInner = Effect_Ref["new"](Data_Maybe.Nothing.value)();
        var cancelOuter = v(function (inner) {
          return function __do() {
            Control_Bind.bind(Effect.bindEffect)(Effect_Ref.read(cancelInner))(
              Data_Foldable.sequence_(Effect.applicativeEffect)(
                Data_Foldable.foldableMaybe
              )
            )();
            var c = subscribe(inner)(k)();
            return Effect_Ref.write(new Data_Maybe.Just(c))(cancelInner)();
          };
        })();
        return function __do() {
          Control_Bind.bind(Effect.bindEffect)(Effect_Ref.read(cancelInner))(
            Data_Foldable.sequence_(Effect.applicativeEffect)(
              Data_Foldable.foldableMaybe
            )
          )();
          return cancelOuter();
        };
      };
    };
  };
  var functorEvent = new Data_Functor.Functor(function (f) {
    return function (v) {
      return function (k) {
        return v(function ($48) {
          return k(f($48));
        });
      };
    };
  });
  var fold = function (f) {
    return function (v) {
      return function (b) {
        return function (k) {
          return function __do() {
            var result = Effect_Ref["new"](b)();
            return v(function (a) {
              return Control_Bind.bind(Effect.bindEffect)(
                Effect_Ref.modify(f(a))(result)
              )(k);
            })();
          };
        };
      };
    };
  };
  var filter = function (p) {
    return function (v) {
      return function (k) {
        return v(function (a) {
          var $34 = p(a);
          if ($34) {
            return k(a);
          }
          return Control_Applicative.pure(Effect.applicativeEffect)(
            Data_Unit.unit
          );
        });
      };
    };
  };
  var create = function __do() {
    var subscribers = Effect_Ref["new"]([])();
    return {
      event: function (k) {
        return function __do() {
          Effect_Ref.modify(function (v) {
            return Data_Semigroup.append(Data_Semigroup.semigroupArray)(v)([k]);
          })(subscribers)();
          return function __do() {
            Effect_Ref.modify(
              Data_Array.deleteBy(Unsafe_Reference.unsafeRefEq)(k)
            )(subscribers)();
            return Data_Unit.unit;
          };
        };
      },
      push: function (a) {
        return Control_Bind.bind(Effect.bindEffect)(
          Effect_Ref.read(subscribers)
        )(
          Data_Foldable.traverse_(Effect.applicativeEffect)(
            Data_Foldable.foldableArray
          )(function (k) {
            return k(a);
          })
        );
      },
    };
  };
  var fix = function (f) {
    var v = Effect_Unsafe.unsafePerformEffect(create);
    var v1 = f(v.event);
    return function (k) {
      return function __do() {
        var c1 = subscribe(v1.input)(v.push)();
        var c2 = subscribe(v1.output)(k)();
        return Control_Apply.applySecond(Effect.applyEffect)(c1)(c2);
      };
    };
  };
  var compactableEvent = new Data_Compactable.Compactable(
    function (xs) {
      return Data_Functor.map(functorEvent)(function (x) {
        return Data_Maybe.fromJust()(x);
      })(filter(Data_Maybe.isJust)(xs));
    },
    function (xs) {
      return {
        left: Data_Functor.map(functorEvent)(Data_Either.fromLeft())(
          filter(Data_Either.isLeft)(xs)
        ),
        right: Data_Functor.map(functorEvent)(Data_Either.fromRight())(
          filter(Data_Either.isRight)(xs)
        ),
      };
    }
  );
  var filterableEvent = new Data_Filterable.Filterable(
    function () {
      return compactableEvent;
    },
    function () {
      return functorEvent;
    },
    filter,
    function (f) {
      var $49 = Data_Functor.map(functorEvent)(function (x) {
        return Data_Maybe.fromJust()(x);
      });
      var $50 = filter(Data_Maybe.isJust);
      var $51 = Data_Functor.map(functorEvent)(f);
      return function ($52) {
        return $49($50($51($52)));
      };
    },
    function (p) {
      return function (xs) {
        return {
          yes: filter(p)(xs),
          no: filter(
            (function () {
              var $53 = Data_HeytingAlgebra.not(
                Data_HeytingAlgebra.heytingAlgebraBoolean
              );
              return function ($54) {
                return $53(p($54));
              };
            })()
          )(xs),
        };
      };
    },
    function (f) {
      return function (xs) {
        return {
          left: Data_Filterable.filterMap(filterableEvent)(
            (function () {
              var $55 = Data_Either.either(Data_Maybe.Just.create)(
                Data_Function["const"](Data_Maybe.Nothing.value)
              );
              return function ($56) {
                return $55(f($56));
              };
            })()
          )(xs),
          right: Data_Filterable.filterMap(filterableEvent)(function ($57) {
            return Data_Either.hush(f($57));
          })(xs),
        };
      };
    }
  );
  var applyEvent = new Control_Apply.Apply(
    function () {
      return functorEvent;
    },
    function (v) {
      return function (v1) {
        return function (k) {
          return function __do() {
            var latestA = Effect_Ref["new"](Data_Maybe.Nothing.value)();
            var latestB = Effect_Ref["new"](Data_Maybe.Nothing.value)();
            var c1 = v(function (a) {
              return function __do() {
                Effect_Ref.write(new Data_Maybe.Just(a))(latestA)();
                return Control_Bind.bind(Effect.bindEffect)(
                  Effect_Ref.read(latestB)
                )(
                  Data_Foldable.traverse_(Effect.applicativeEffect)(
                    Data_Foldable.foldableMaybe
                  )(function ($58) {
                    return k(a($58));
                  })
                )();
              };
            })();
            var c2 = v1(function (b) {
              return function __do() {
                Effect_Ref.write(new Data_Maybe.Just(b))(latestB)();
                return Control_Bind.bind(Effect.bindEffect)(
                  Effect_Ref.read(latestA)
                )(
                  Data_Foldable.traverse_(Effect.applicativeEffect)(
                    Data_Foldable.foldableMaybe
                  )(function ($59) {
                    return k(
                      (function (v2) {
                        return v2(b);
                      })($59)
                    );
                  })
                )();
              };
            })();
            return Control_Apply.applySecond(Effect.applyEffect)(c1)(c2);
          };
        };
      };
    }
  );
  var applicativeEvent = new Control_Applicative.Applicative(
    function () {
      return applyEvent;
    },
    function (a) {
      return function (k) {
        return function __do() {
          k(a)();
          return Control_Applicative.pure(Effect.applicativeEffect)(
            Data_Unit.unit
          );
        };
      };
    }
  );
  var altEvent = new Control_Alt.Alt(
    function () {
      return functorEvent;
    },
    function (v) {
      return function (v1) {
        return function (k) {
          return function __do() {
            var c1 = v(k)();
            var c2 = v1(k)();
            return Control_Apply.applySecond(Effect.applyEffect)(c1)(c2);
          };
        };
      };
    }
  );
  var plusEvent = new Control_Plus.Plus(
    function () {
      return altEvent;
    },
    function (v) {
      return Control_Applicative.pure(Effect.applicativeEffect)(
        Control_Applicative.pure(Effect.applicativeEffect)(Data_Unit.unit)
      );
    }
  );
  var alternativeEvent = new Control_Alternative.Alternative(
    function () {
      return applicativeEvent;
    },
    function () {
      return plusEvent;
    }
  );
  var eventIsEvent = new FRP_Event_Class.IsEvent(
    function () {
      return alternativeEvent;
    },
    function () {
      return filterableEvent;
    },
    fix,
    fold,
    keepLatest,
    sampleOn
  );
  exports["makeEvent"] = makeEvent;
  exports["subscribe"] = subscribe;
  exports["functorEvent"] = functorEvent;
  exports["eventIsEvent"] = eventIsEvent;
})(PS);
(function (exports) {
  "use strict";

  exports.copyRecord = function (rec) {
    var copy = {};
    for (var key in rec) {
      if ({}.hasOwnProperty.call(rec, key)) {
        copy[key] = rec[key];
      }
    }
    return copy;
  };
})((PS["Record.Builder"] = PS["Record.Builder"] || {}));
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Record.Builder"] = $PS["Record.Builder"] || {};
  var exports = $PS["Record.Builder"];
  var $foreign = $PS["Record.Builder"];
  var Control_Category = $PS["Control.Category"];
  var categoryBuilder = Control_Category.categoryFn;
  var build = function (v) {
    return function (r1) {
      return v($foreign.copyRecord(r1));
    };
  };
  exports["build"] = build;
  exports["categoryBuilder"] = categoryBuilder;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Type.Data.RowList"] = $PS["Type.Data.RowList"] || {};
  var exports = $PS["Type.Data.RowList"];
  var RLProxy = (function () {
    function RLProxy() {}
    RLProxy.value = new RLProxy();
    return RLProxy;
  })();
  exports["RLProxy"] = RLProxy;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Heterogeneous.Mapping"] = $PS["Heterogeneous.Mapping"] || {};
  var exports = $PS["Heterogeneous.Mapping"];
  var Control_Category = $PS["Control.Category"];
  var Record_Builder = $PS["Record.Builder"];
  var Type_Data_RowList = $PS["Type.Data.RowList"];
  var ConstMapping = function (x) {
    return x;
  };
  var MapRecordWithIndex = function (mapRecordWithIndexBuilder) {
    this.mapRecordWithIndexBuilder = mapRecordWithIndexBuilder;
  };
  var HMap = function (hmap) {
    this.hmap = hmap;
  };
  var mapRecordWithIndexNil = new MapRecordWithIndex(function (v) {
    return function (v1) {
      return Control_Category.identity(Record_Builder.categoryBuilder);
    };
  });
  var mapRecordWithIndexBuilder = function (dict) {
    return dict.mapRecordWithIndexBuilder;
  };
  var hmapRecord = function (dictRowToList) {
    return function (dictMapRecordWithIndex) {
      return new HMap(
        (function () {
          var $77 = mapRecordWithIndexBuilder(dictMapRecordWithIndex)(
            Type_Data_RowList.RLProxy.value
          );
          return function ($78) {
            return Record_Builder.build($77(ConstMapping($78)));
          };
        })()
      );
    };
  };
  var hmap = function (dict) {
    return dict.hmap;
  };
  exports["hmap"] = hmap;
  exports["hmapRecord"] = hmapRecord;
  exports["mapRecordWithIndexNil"] = mapRecordWithIndexNil;
})(PS);
(function ($PS) {
  "use strict";
  $PS["FRP.Behavior.Audio"] = $PS["FRP.Behavior.Audio"] || {};
  var exports = $PS["FRP.Behavior.Audio"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Array = $PS["Data.Array"];
  var Data_EuclideanRing = $PS["Data.EuclideanRing"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Int = $PS["Data.Int"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_Unit = $PS["Data.Unit"];
  var Effect = $PS["Effect"];
  var Effect_Ref = $PS["Effect.Ref"];
  var FRP_Behavior = $PS["FRP.Behavior"];
  var FRP_Event = $PS["FRP.Event"];
  var Heterogeneous_Mapping = $PS["Heterogeneous.Mapping"];
  var withParam = function (incr) {
    return function (e) {
      return FRP_Event.makeEvent(function (k) {
        return FRP_Event.subscribe(e)(function (value) {
          return function __do() {
            var param = incr();
            return k({
              value: value,
              param: param,
            })();
          };
        });
      });
    };
  };

  // hack because cpp ffi doesn't have whileE yet
  var whileEImpl = function (b) {
    return function (m) {
      return Effect.whileE(b)(m);
    };
  };
  var soundify = function (e) {
    return function (scene) {
      return function (render) {
        return FRP_Event.subscribe(
          FRP_Behavior.sample_(FRP_Event.eventIsEvent)(scene)(e)
        )(render);
      };
    };
  };
  var paramGetter = function (dictHomogeneous) {
    return function (dictHomogeneous1) {
      return function (dictHMap) {
        return function (i) {
          return function (a) {
            return Heterogeneous_Mapping.hmap(dictHMap)(i)(a);
          };
        };
      };
    };
  };

  // | Create an event which fires for every audio frame.
  // | Note that this does not have a canceler.  Cancellation from audio
  // | processing should be handled in the `process()` function of the worklet.
  var audioDriver = function (incr) {
    return FRP_Event.makeEvent(function (k) {
      return function __do() {
        whileEImpl(incr)(k(Data_Unit.unit))();
        return Control_Applicative.pure(Effect.applicativeEffect)(
          Data_Unit.unit
        );
      };
    });
  };

  // | A generic behavior from a parameter
  var _behavior = function (eff) {
    return FRP_Behavior.behavior(function (e) {
      return Data_Functor.map(FRP_Event.functorEvent)(function (v) {
        return v.value(v.param);
      })(withParam(eff)(e));
    });
  };
  var controlParams = function (dictHomogeneous) {
    return _behavior;
  };
  var currentTime = _behavior;
  var sampleFrame = _behavior;

  // | The inner audio loop
  // | The same as audioIO, but it keeps the sink interleaved.
  // | For web audio, this avoids additional memory copying.
  // | Note that the outer array enclosing the samples is facultative here,
  // | as interleaved audio is just channels and does not have an extra dimension.
  var audioIOInterleaved = function (dictHomogeneous) {
    return function (dictHomogeneous1) {
      return function (dictHMap) {
        return function (processor) {
          return function (sampleRate) {
            return function (params) {
              return function (currentSample) {
                return function (nChannels) {
                  return function (bufferLength) {
                    return function (sink) {
                      return function __do() {
                        var curpos = Effect_Ref["new"](0)();
                        var output = Data_Traversable.sequence(
                          Data_Traversable.traversableArray
                        )(Effect.applicativeEffect)(
                          Data_Array.replicate((nChannels * bufferLength) | 0)(
                            Effect_Ref["new"](0.0)
                          )
                        )();
                        var _driver = audioDriver(function __do() {
                          var cp = Effect_Ref.read(curpos)();
                          Effect_Ref.write((cp + 1) | 0)(curpos)();
                          return cp < bufferLength;
                        });
                        var _behaviorCurrentTime = currentTime(function __do() {
                          var cp = Effect_Ref.read(curpos)();
                          var ct = (cp + currentSample) | 0;
                          return (
                            Data_Int.toNumber(ct) /
                            Data_Int.toNumber(sampleRate)
                          );
                        });
                        var _secondsToBehaviorSampleFrame = function (lb) {
                          return sampleFrame(function __do() {
                            var cp0 = Effect_Ref.read(curpos)();
                            var lookback = (function () {
                              var $20 = lb < 0.0;
                              if ($20) {
                                return 0.0;
                              }
                              return lb;
                            })();
                            var lookbackInSamples =
                              (((bufferLength - cp0) | 0) +
                                Data_Int.floor(
                                  lookback * Data_Int.toNumber(sampleRate)
                                )) |
                              0;
                            var numberOfBlocsToSkip = Data_EuclideanRing.div(
                              Data_EuclideanRing.euclideanRingInt
                            )(lookbackInSamples)(bufferLength);
                            var offsetFromEndOfBloc =
                              (lookbackInSamples -
                                ((numberOfBlocsToSkip * bufferLength) | 0)) |
                              0;
                            var floatsToSkipUntilDesiredBloc =
                              (((numberOfBlocsToSkip * bufferLength) | 0) *
                                nChannels) |
                              0;
                            var floatsToSkipUntilDesiredChannel = function (i) {
                              return (
                                (((((nChannels - 1) | 0) - i) | 0) *
                                  bufferLength) |
                                0
                              );
                            };
                            var sinkLen = Data_Array.length(sink);
                            var frame = [
                              Data_Functor.map(Data_Functor.functorArray)(
                                function (i) {
                                  return Data_Maybe.fromMaybe(0.0)(
                                    Data_Array.index(sink)(
                                      (((((sinkLen -
                                        floatsToSkipUntilDesiredBloc) |
                                        0) -
                                        floatsToSkipUntilDesiredChannel(i)) |
                                        0) -
                                        offsetFromEndOfBloc) |
                                        0
                                    )
                                  );
                                }
                              )(Data_Array.range(0)((nChannels - 1) | 0)),
                            ];
                            return frame;
                          });
                        };
                        var _behaviorControlParams = controlParams()(
                          function __do() {
                            var cp = Effect_Ref.read(curpos)();
                            return paramGetter()()(dictHMap)(cp)(params);
                          }
                        );
                        var chain = processor(_behaviorCurrentTime)(
                          _secondsToBehaviorSampleFrame
                        )(_behaviorControlParams);
                        var bam = soundify(_driver)(chain)(function (frame) {
                          return function __do() {
                            var cp = Effect_Ref.read(curpos)();
                            Data_Functor["void"](Effect.functorEffect)(
                              Data_Traversable.sequence(
                                Data_Traversable.traversableMaybe
                              )(Effect.applicativeEffect)(
                                Control_Bind.bind(Data_Maybe.bindMaybe)(
                                  Data_Array.head(frame)
                                )(function (channels) {
                                  return Control_Applicative.pure(
                                    Data_Maybe.applicativeMaybe
                                  )(
                                    Data_Traversable.sequence(
                                      Data_Traversable.traversableArray
                                    )(Effect.applicativeEffect)(
                                      Data_Array.mapWithIndex(function (i) {
                                        return function (sample) {
                                          return Data_Traversable.sequence(
                                            Data_Traversable.traversableMaybe
                                          )(Effect.applicativeEffect)(
                                            Control_Bind.bind(
                                              Data_Maybe.bindMaybe
                                            )(
                                              Data_Array.index(output)(
                                                (((i * bufferLength) | 0) +
                                                  cp) |
                                                  0
                                              )
                                            )(function (ref) {
                                              return Control_Applicative.pure(
                                                Data_Maybe.applicativeMaybe
                                              )(Effect_Ref.write(sample)(ref));
                                            })
                                          );
                                        };
                                      })(channels)
                                    )
                                  );
                                })
                              )
                            )();
                            return Data_Unit.unit;
                          };
                        })();
                        bam();
                        return Data_Traversable.sequence(
                          Data_Traversable.traversableArray
                        )(Effect.applicativeEffect)(
                          Data_Functor.map(Data_Functor.functorArray)(
                            Effect_Ref.read
                          )(output)
                        )();
                      };
                    };
                  };
                };
              };
            };
          };
        };
      };
    };
  };
  exports["audioIOInterleaved"] = audioIOInterleaved;
})(PS);
(function ($PS) {
  // Generated by purs version 0.13.8
  "use strict";
  $PS["Main"] = $PS["Main"] || {};
  var exports = $PS["Main"];
  var Control_Apply = $PS["Control.Apply"];
  var Data_Array = $PS["Data.Array"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Semiring = $PS["Data.Semiring"];
  var Data_Show = $PS["Data.Show"];
  var Effect_Class = $PS["Effect.Class"];
  var Effect_Class_Console = $PS["Effect.Class.Console"];
  var FRP_Behavior = $PS["FRP.Behavior"];
  var FRP_Behavior_Audio = $PS["FRP.Behavior.Audio"];
  var FRP_Event = $PS["FRP.Event"];
  var Heterogeneous_Mapping = $PS["Heterogeneous.Mapping"];
  var mulSampleFrame = function (n) {
    return Data_Functor.map(Data_Functor.functorArray)(
      Data_Functor.map(Data_Functor.functorArray)(function (v) {
        return v * n;
      })
    );
  };
  var simpleProcessor = function (v) {
    return function (audio) {
      return function (params) {
        return Data_Functor.map(
          FRP_Behavior.functorABehavior(FRP_Event.functorEvent)
        )(mulSampleFrame(0.25))(audio(0.0));
      };
    };
  };
  var frameZip = Data_Array.zipWith(
    Data_Array.zipWith(Data_Semiring.add(Data_Semiring.semiringNumber))
  );
  var delayProcessor = function (v) {
    return function (audio) {
      return function (params) {
        return Control_Apply.apply(
          FRP_Behavior.applyABehavior(FRP_Event.functorEvent)
        )(
          Data_Functor.map(
            FRP_Behavior.functorABehavior(FRP_Event.functorEvent)
          )(frameZip)(
            Data_Functor.map(
              FRP_Behavior.functorABehavior(FRP_Event.functorEvent)
            )(mulSampleFrame(0.25))(audio(0.0))
          )
        )(
          Data_Functor.map(
            FRP_Behavior.functorABehavior(FRP_Event.functorEvent)
          )(mulSampleFrame(0.5))(audio(1.0))
        );
      };
    };
  };
  var main = (function () {
    var audioIn = Data_Semigroup.append(Data_Semigroup.semigroupArray)(
      Data_Array.replicate(16)(0.125)
    )(Data_Array.replicate(16)(1.0));
    return function __do() {
      var aud = FRP_Behavior_Audio.audioIOInterleaved()()(
        Heterogeneous_Mapping.hmapRecord()(
          Heterogeneous_Mapping.mapRecordWithIndexNil
        )
      )(delayProcessor)(44100)({})(0)(1)(128)(audioIn)();
      return Effect_Class_Console.log(Effect_Class.monadEffectEffect)(
        Data_Show.show(Data_Show.showArray(Data_Show.showNumber))(aud)
      )();
    };
  })();
  exports["frameZip"] = frameZip;
  exports["mulSampleFrame"] = mulSampleFrame;
  exports["simpleProcessor"] = simpleProcessor;
  exports["delayProcessor"] = delayProcessor;
  exports["main"] = main;
})(PS);
/**
 * A simple demonstration of WASM-powered AudioWorkletProcessor.
 *
 * @class PureScriptWorkletProcessor
 * @extends AudioWorkletProcessor
 */
class PureScriptWorkletProcessor extends AudioWorkletProcessor {
  /**
   * @constructor
   */
  constructor() {
    super();
    this.sink = new Array(44100 * 5 * 2).fill(0.0);
    this.currentSample = 0;
  }

  process(inputs, outputs, parameters) {
    let input = inputs[0];
    let output = outputs[0];

    let channelCount = input.length;
    if (channelCount == 0) {
      return true;
    }
    let bufferLength = input[0].length;

    let flat = Array.prototype.concat.apply([], input);
    this.sink = this.sink.slice(flat.length).concat(flat);
    let out = PS["FRP.Behavior.Audio"].audioIOInterleaved()()(
      PS["Heterogeneous.Mapping"].hmapRecord()(
        PS["Heterogeneous.Mapping"].mapRecordWithIndexNil
      )
    )(PS["Main"].delayProcessor)(sampleRate)({})(this.currentSample)(
      channelCount
    )(bufferLength)(flat)();
    for (var i = 0; i < channelCount; i++) {
      output[i] = out.slice(i * bufferLength, (i + 1) * bufferLength);
    }
    this.currentSample += bufferLength;
    return true;
  }
}

registerProcessor("pure-script-worklet-processor", PureScriptWorkletProcessor);
